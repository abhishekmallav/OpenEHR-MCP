# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OVZ0O6wJ6aOix6lShu3NIGqeBvbA8G1q
"""

#getting response
import requests

BASE_URL = "http://localhost:8080/ehrbase/rest/openehr/v1"
ehr_id = "d6328a8b-22f1-4077-8981-1ffea623258a"
tpl_id = "patient_visit_template"

# Step 1: Fetch the latest composition UID via AQL
aql_query = {
    "q": f"""
        SELECT
            c/uid/value AS composition_uid,
            c/name/value AS composition_name,
            c/context/start_time/value AS time_created
        FROM EHR e
            CONTAINS COMPOSITION c
        WHERE e/ehr_id/value = '{ehr_id}'
          AND c/archetype_details/template_id/value = '{tpl_id}'
        ORDER BY c/context/start_time/value DESC
        LIMIT 1
    """
}

query_url = f"{BASE_URL}/query/aql"
resp = requests.post(query_url, json=aql_query, headers={"accept": "application/json"})
resp.raise_for_status()

result = resp.json()
composition_uid = result["rows"][0][0]  # first column = composition_uid

#print("Fetched composition UID:", composition_uid)

## Step 2: Fetch full composition
composition_url = f"{BASE_URL}/ehr/{ehr_id}/composition/{composition_uid}"
comp_resp = requests.get(composition_url, headers={"accept": "application/json"})
comp_resp.raise_for_status()
data = comp_resp.json()

# Step 3: Extract data
clinical_interpretation = None
comment = None
blood_pressure = {}

for content in data.get("content", []):
    if content.get("_type") == "OBSERVATION" and content["name"]["value"] == "Blood pressure":
        events = content.get("data", {}).get("events", [])
        for event in events:
            # Blood pressure numeric values
            for item in event.get("data", {}).get("items", []):
                name = item.get("name", {}).get("value", "")
                value = item.get("value", {}).get("magnitude")
                if name in ["Systolic", "Diastolic", "Mean arterial pressure", "Pulse pressure"]:
                    blood_pressure[name] = value
                elif name == "Clinical interpretation":
                    clinical_interpretation = item.get("value", {}).get("value")
                elif name == "Comment":
                    comment = item.get("value", {}).get("value")

            # Tilt under event ‚Üí state ‚Üí items
            for state_item in event.get("state", {}).get("items", []):
                if state_item.get("name", {}).get("value") == "Tilt":
                    blood_pressure["Tilt"] = state_item.get("value", {}).get("magnitude")

# Step 4: Print results
print("\n--- Blood Pressure Readings ---")
for k, v in blood_pressure.items():
    print(f"{k}: {v} {'mmHg' if k != 'Tilt' else 'deg'}")

print("\n--- Clinical Interpretation ---\n", clinical_interpretation)
print("\n--- Comment ---\n", comment)

import os
import torch
from qdrant_client import QdrantClient
from transformers import AutoTokenizer, AutoModel
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import PromptTemplate

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Device: {device}")

# IMPORTANT: Set GEMINI_API_KEY environment variable before running
# export GEMINI_API_KEY="your_api_key_here"
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable is required. Set it with: export GEMINI_API_KEY='your_key'")

os.environ["GOOGLE_API_KEY"] = GEMINI_API_KEY

llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0)

client = QdrantClient(url="http://localhost:6333")
collection_name = "icd_mpnet_basev2"

model_name = "sentence-transformers/all-mpnet-base-v2"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModel.from_pretrained(model_name).to(device).eval()

# --- Convert Clinical Interpretation to ICD-based Descriptions (Improved) ---

if not clinical_interpretation:
    raise ValueError("‚ùå No clinical_interpretation found. Ensure EHR extraction ran successfully.")

prompt = f"""
You are a certified ICD-10 coding specialist.

Your goal: From the given *clinical interpretation text*, extract only the distinct diagnostic entities that would be coded in ICD-10.

Guidelines:
1. Use official ICD-10 terminology (e.g., ‚ÄúCalculus of gallbladder‚Äù, ‚ÄúFatty liver‚Äù, ‚ÄúHydronephrosis due to calculus‚Äù).
2. Exclude:
   - Duplicate or overlapping terms (e.g., ‚ÄúCalculus of ureter‚Äù when already covered by ‚ÄúHydronephrosis due to ureteric calculus‚Äù).
   - General organ descriptions (‚Äúliver shows echogenicity‚Äù) that are not billable diagnoses.
   - Symptom descriptions or incidental findings unless diagnostic (e.g., skip ‚Äúmild‚Äù, ‚Äúreactive‚Äù, ‚Äúsuggestive‚Äù unless part of ICD phrasing).
3. If multiple related findings describe a single condition, **merge them** into one canonical ICD-style phrase.
4. Output only distinct diagnostic phrases, each on a new line ‚Äî no numbering, no bullets.
5. If the text mentions gallstones or cholelithiasis, rewrite in ICD form as ‚ÄúCalculus of gallbladder ‚Ä¶‚Äù.

Clinical Interpretation:
{clinical_interpretation}

Output:
Distinct ICD-10-style diagnostic phrases only.
"""


icd_response = llm.invoke(prompt).content.strip()
queries = [q.strip('-‚Ä¢ ').strip().rstrip('.') for q in icd_response.split('\n') if q.strip()]

print("‚úÖ Refined ICD-style queries:\n")
for q in queries:
    print("-", q)

# --- Embed Queries and Retrieve ICD Codes from Qdrant ---

for text in queries:
    # Generate embedding (mean pooling, simple & effective)
    inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=128).to(device)
    with torch.no_grad():
        embedding = model(**inputs).last_hidden_state.mean(dim=1).squeeze().cpu().numpy()

    # Search in Qdrant
    results = client.query_points(
        collection_name=collection_name,
        query=embedding.tolist(),
        limit=5,
        with_payload=True
    )

    # Print top results
    print(f"\nüîç Query: {text}")
    for i, r in enumerate(results.points, 1):
        print(f"  {i}. {r.payload['code']} - {r.payload['short']} (Score: {r.score:.3f})")